"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GravatarService = void 0;
const md5_1 = require("ts-md5/dist/md5");
const image_rating_1 = require("../Domain/image-rating");
const fs_1 = require("fs");
const method_calls_1 = require("../Domain/method-calls");
const method_responses_1 = require("../Domain/method-responses");
class GravatarService {
    constructor(userEmail, userPassword) {
        this.email = `${userEmail}`.trim().toLowerCase();
        this.emailHash = this.hashEmail(this.email);
        this._password = userPassword;
    }
    get gravatarImageUrl() {
        return `https://www.gravatar.com/avatar/${this.emailHash}`;
    }
    hashEmail(email) {
        return md5_1.Md5.hashStr(email).toString();
    }
    exists(...emailAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = emailAddresses.length ? emailAddresses : [this.email];
            const hashes = addresses.map(this.hashEmail);
            const methodCall = new method_calls_1.ExistsMethodCall(hashes, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.ExistsMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    addresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.AddressesMethodCall(this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.AddressesMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    userImages() {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.UserImagesMethodCall(this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.UserImagesMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    saveImage(imageFilePath, imageRating = image_rating_1.ImageRating.G) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs_1.existsSync(imageFilePath)) {
                throw new Error(`file not found: ${imageFilePath}`);
            }
            const bitmap = fs_1.readFileSync(imageFilePath);
            const imageData = Buffer.from(bitmap).toString("base64");
            const methodCall = new method_calls_1.SaveDataMethodCall(imageData, imageRating, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.SaveImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    saveEncodedImage(base64String, imageRating = image_rating_1.ImageRating.G) {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.SaveDataMethodCall(base64String, imageRating, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.SaveImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    saveImageUrl(imageUrl, imageRating = image_rating_1.ImageRating.G) {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.SaveImageMethodCall(imageUrl, imageRating, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.SaveImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    useUserImage(imageName, ...emailAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = emailAddresses.length ? emailAddresses : [this.email];
            const methodCall = new method_calls_1.UseUserImageMethodCall(imageName, addresses, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.UseUserImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    removeImage(...emailAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = emailAddresses.length ? emailAddresses : [this.email];
            const methodCall = new method_calls_1.RemoveImageMethodCall(addresses, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.RemoveImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    deleteUserImage(imageName) {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.DeleteUserImageMethodCall(imageName, this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.DeleteUserImageMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
    test() {
        return __awaiter(this, void 0, void 0, function* () {
            const methodCall = new method_calls_1.TestMethodCall(this._password);
            const response = yield this.http.rpc(methodCall.xml);
            if (response.ok) {
                const xmlResponse = yield response.text();
                return new method_responses_1.TestMethodResponse(xmlResponse);
            }
            else {
                throw new Error(response.statusText);
            }
        });
    }
}
exports.GravatarService = GravatarService;
