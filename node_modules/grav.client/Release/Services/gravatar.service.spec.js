"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("jasmine");
const path_1 = require("path");
const fs_1 = require("fs");
const gravatar_service_1 = require("./gravatar.service");
const http_shim_1 = require("../Infrastructure/http-shim");
const primitive_stubs_1 = require("../Common/TestDoubles/primitive-stubs");
const stub = __importStar(require("../Common/TestDoubles/http-response-stubs"));
const mock_factory_1 = require("../Common/TestDoubles/mock-factory");
describe("GravatarService", () => {
    let service;
    beforeAll(() => {
        service = new gravatar_service_1.GravatarService(primitive_stubs_1.email, primitive_stubs_1.password);
    });
    it("should check if account exists", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.ExistsHttpResponse(service.emailHash);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.exists();
        expect(response.success).toBe(true);
    }));
    it("should check if multiple accounts exist", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.ExistsMultipleHttpResponse(primitive_stubs_1.emailHash, primitive_stubs_1.email2Hash);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.exists(primitive_stubs_1.email, primitive_stubs_1.email2);
        expect(response.success).toBe(true);
    }));
    it("should have gravatar image url", () => {
        service.http = new http_shim_1.HttpShim(service.emailHash);
        const rgx = new RegExp("^https://www.gravatar.com/avatar/(.*)$");
        expect(rgx.test(service.gravatarImageUrl)).toBe(true);
    });
    it("should get user email address", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.AddressesHttpResponse(service.emailHash);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.addresses();
        expect(response.userAddresses).toBeDefined();
    }));
    it("should get user email addresses", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.AddressesMultipleHttpResponse(primitive_stubs_1.email, primitive_stubs_1.email2);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.addresses();
        expect(response.userAddresses).toBeDefined();
    }));
    it("should get user images", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.UserImagesHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.userImages();
        expect(response.userImages).toBeDefined();
    }));
    it("should get single user image", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.UserImageHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.userImages();
        expect(response.userImages.length).toBe(1);
    }));
    it("should get empty image array", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.UserImagesNoneHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.userImages();
        expect(response.userImages.length).toBe(0);
    }));
    it("should save image file", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.SaveImageHttpResponse();
        const imageFilePath = path_1.join(__dirname, "../Common/Assets/bubba.jpg");
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.saveImage(imageFilePath);
        expect(response.imageName).toBeDefined();
    }));
    it("should save encoded image", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.SaveEncodedImageHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const imgPath = path_1.join(__dirname, "../Common/Assets/gump.jpg");
        const bitmap = fs_1.readFileSync(imgPath);
        const imageData = Buffer.from(bitmap).toString("base64");
        const response = yield service.saveEncodedImage(imageData);
        expect(response.imageName).toBeDefined();
    }));
    it("should save image url", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.SaveImageUrlHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.saveImageUrl(primitive_stubs_1.imageUrl);
        expect(response.imageName).toBeDefined();
    }));
    it("should use user image", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.UseUserImageHttpResponse(primitive_stubs_1.email);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.useUserImage(primitive_stubs_1.imageName);
        expect(response.success).toBe(true);
    }));
    it("should use user image for multiple email addresses", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.UseUserImageMultipleHttpResponse(primitive_stubs_1.email, primitive_stubs_1.email2);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.useUserImage(primitive_stubs_1.imageName, primitive_stubs_1.email, primitive_stubs_1.email2);
        expect(response.success).toBe(true);
    }));
    it("should remove image", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.RemoveImageHttpResponse(primitive_stubs_1.email);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.removeImage();
        expect(response.success).toBe(true);
    }));
    it("should remove image for multiple email addresses", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.RemoveImageMultipleHttpResponse(primitive_stubs_1.email, primitive_stubs_1.email2);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.removeImage(primitive_stubs_1.email, primitive_stubs_1.email2);
        expect(response.success).toBe(true);
    }));
    it("should delete user image", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.DeleteUserImageHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.deleteUserImage(primitive_stubs_1.imageName);
        expect(response.success).toBe(true);
    }));
    it("should do sanity check", () => __awaiter(void 0, void 0, void 0, function* () {
        const responseStub = stub.TestHttpResponse();
        service.http = mock_factory_1.mockHttpShim(responseStub);
        const response = yield service.test();
        expect(response.response).toBeDefined();
    }));
    it("should throw", () => __awaiter(void 0, void 0, void 0, function* () {
        let error = null;
        const responseStub = stub.FaultHttpResponse(primitive_stubs_1.errorMessage);
        service.http = mock_factory_1.mockHttpShim(responseStub);
        try {
            yield service.exists();
        }
        catch (ex) {
            error = ex;
        }
        finally {
            expect(error).toBeDefined();
        }
    }));
    it("should fail", () => {
        const validImageFilePath = path_1.join(__dirname, "../Common/Assets/bubba.jpg");
        [
            { methodName: "exists", args: [] },
            { methodName: "addresses", args: [] },
            { methodName: "userImages", args: [] },
            { methodName: "saveImage", args: [primitive_stubs_1.fakeImageFilePath] },
            { methodName: "saveImage", args: [validImageFilePath] },
            { methodName: "saveEncodedImage", args: [primitive_stubs_1.imageData] },
            { methodName: "saveImageUrl", args: [primitive_stubs_1.imageUrl] },
            { methodName: "useUserImage", args: [primitive_stubs_1.imageName] },
            { methodName: "removeImage", args: [] },
            { methodName: "deleteUserImage", args: [primitive_stubs_1.imageName] },
            { methodName: "test", args: [] },
        ].forEach((row) => __awaiter(void 0, void 0, void 0, function* () {
            const testData = row;
            const responseStub = stub.BadRequestHttpResponse(primitive_stubs_1.errorMessage);
            const httpShim = mock_factory_1.mockHttpShim(responseStub);
            service.http = httpShim;
            const method = service[testData.methodName].bind(service);
            let error = null;
            try {
                const response = yield method(...testData.args);
            }
            catch (ex) {
                error = ex;
            }
            finally {
                expect(error).toBeDefined();
            }
        }));
    });
});
